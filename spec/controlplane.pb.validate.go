// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: proto/controlplane.proto

package spec

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Address with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Address) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Address with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in AddressMultiError, or nil if none found.
func (m *Address) ValidateAll() error {
	return m.validate(true)
}

func (m *Address) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if ip := net.ParseIP(m.GetIpaddress()); ip == nil {
		err := AddressValidationError{
			field:  "Ipaddress",
			reason: "value must be a valid IP address",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return AddressMultiError(errors)
	}

	return nil
}

// AddressMultiError is an error wrapping multiple validation errors returned
// by Address.ValidateAll() if the designated constraints aren't met.
type AddressMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddressMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddressMultiError) AllErrors() []error { return m }

// AddressValidationError is the validation error returned by Address.Validate
// if the designated constraints aren't met.
type AddressValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddressValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddressValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddressValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddressValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddressValidationError) ErrorName() string { return "AddressValidationError" }

// Error satisfies the builtin error interface
func (e AddressValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddress.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddressValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddressValidationError{}

// Validate checks the field values on AddressAndPort with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AddressAndPort) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddressAndPort with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AddressAndPortMultiError,
// or nil if none found.
func (m *AddressAndPort) ValidateAll() error {
	return m.validate(true)
}

func (m *AddressAndPort) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetIpaddress()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AddressAndPortValidationError{
					field:  "Ipaddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AddressAndPortValidationError{
					field:  "Ipaddress",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIpaddress()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AddressAndPortValidationError{
				field:  "Ipaddress",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if val := m.GetPort(); val < 1 || val > 65535 {
		err := AddressAndPortValidationError{
			field:  "Port",
			reason: "value must be inside range [1, 65535]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return AddressAndPortMultiError(errors)
	}

	return nil
}

// AddressAndPortMultiError is an error wrapping multiple validation errors
// returned by AddressAndPort.ValidateAll() if the designated constraints
// aren't met.
type AddressAndPortMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddressAndPortMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddressAndPortMultiError) AllErrors() []error { return m }

// AddressAndPortValidationError is the validation error returned by
// AddressAndPort.Validate if the designated constraints aren't met.
type AddressAndPortValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddressAndPortValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddressAndPortValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddressAndPortValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddressAndPortValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddressAndPortValidationError) ErrorName() string { return "AddressAndPortValidationError" }

// Error satisfies the builtin error interface
func (e AddressAndPortValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddressAndPort.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddressAndPortValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddressAndPortValidationError{}

// Validate checks the field values on UnderlayUnknown with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UnderlayUnknown) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UnderlayUnknown with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UnderlayUnknownMultiError, or nil if none found.
func (m *UnderlayUnknown) ValidateAll() error {
	return m.validate(true)
}

func (m *UnderlayUnknown) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetEndpoint()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UnderlayUnknownValidationError{
					field:  "Endpoint",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UnderlayUnknownValidationError{
					field:  "Endpoint",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEndpoint()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UnderlayUnknownValidationError{
				field:  "Endpoint",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UnderlayUnknownMultiError(errors)
	}

	return nil
}

// UnderlayUnknownMultiError is an error wrapping multiple validation errors
// returned by UnderlayUnknown.ValidateAll() if the designated constraints
// aren't met.
type UnderlayUnknownMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UnderlayUnknownMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UnderlayUnknownMultiError) AllErrors() []error { return m }

// UnderlayUnknownValidationError is the validation error returned by
// UnderlayUnknown.Validate if the designated constraints aren't met.
type UnderlayUnknownValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UnderlayUnknownValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UnderlayUnknownValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UnderlayUnknownValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UnderlayUnknownValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UnderlayUnknownValidationError) ErrorName() string { return "UnderlayUnknownValidationError" }

// Error satisfies the builtin error interface
func (e UnderlayUnknownValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUnderlayUnknown.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UnderlayUnknownValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UnderlayUnknownValidationError{}

// Validate checks the field values on UnderlayTailscale with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UnderlayTailscale) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UnderlayTailscale with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UnderlayTailscaleMultiError, or nil if none found.
func (m *UnderlayTailscale) ValidateAll() error {
	return m.validate(true)
}

func (m *UnderlayTailscale) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetEndpoint()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UnderlayTailscaleValidationError{
					field:  "Endpoint",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UnderlayTailscaleValidationError{
					field:  "Endpoint",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEndpoint()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UnderlayTailscaleValidationError{
				field:  "Endpoint",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UnderlayTailscaleMultiError(errors)
	}

	return nil
}

// UnderlayTailscaleMultiError is an error wrapping multiple validation errors
// returned by UnderlayTailscale.ValidateAll() if the designated constraints
// aren't met.
type UnderlayTailscaleMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UnderlayTailscaleMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UnderlayTailscaleMultiError) AllErrors() []error { return m }

// UnderlayTailscaleValidationError is the validation error returned by
// UnderlayTailscale.Validate if the designated constraints aren't met.
type UnderlayTailscaleValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UnderlayTailscaleValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UnderlayTailscaleValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UnderlayTailscaleValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UnderlayTailscaleValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UnderlayTailscaleValidationError) ErrorName() string {
	return "UnderlayTailscaleValidationError"
}

// Error satisfies the builtin error interface
func (e UnderlayTailscaleValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUnderlayTailscale.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UnderlayTailscaleValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UnderlayTailscaleValidationError{}

// Validate checks the field values on Curve25519Key with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Curve25519Key) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Curve25519Key with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in Curve25519KeyMultiError, or
// nil if none found.
func (m *Curve25519Key) ValidateAll() error {
	return m.validate(true)
}

func (m *Curve25519Key) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetKey()) != 32 {
		err := Curve25519KeyValidationError{
			field:  "Key",
			reason: "value length must be 32 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return Curve25519KeyMultiError(errors)
	}

	return nil
}

// Curve25519KeyMultiError is an error wrapping multiple validation errors
// returned by Curve25519Key.ValidateAll() if the designated constraints
// aren't met.
type Curve25519KeyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Curve25519KeyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Curve25519KeyMultiError) AllErrors() []error { return m }

// Curve25519KeyValidationError is the validation error returned by
// Curve25519Key.Validate if the designated constraints aren't met.
type Curve25519KeyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Curve25519KeyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Curve25519KeyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Curve25519KeyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Curve25519KeyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Curve25519KeyValidationError) ErrorName() string { return "Curve25519KeyValidationError" }

// Error satisfies the builtin error interface
func (e Curve25519KeyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCurve25519Key.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Curve25519KeyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Curve25519KeyValidationError{}

// Validate checks the field values on Curve25519KeyPair with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *Curve25519KeyPair) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Curve25519KeyPair with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// Curve25519KeyPairMultiError, or nil if none found.
func (m *Curve25519KeyPair) ValidateAll() error {
	return m.validate(true)
}

func (m *Curve25519KeyPair) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPublickey()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Curve25519KeyPairValidationError{
					field:  "Publickey",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Curve25519KeyPairValidationError{
					field:  "Publickey",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPublickey()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Curve25519KeyPairValidationError{
				field:  "Publickey",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPrivatekey()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, Curve25519KeyPairValidationError{
					field:  "Privatekey",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, Curve25519KeyPairValidationError{
					field:  "Privatekey",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPrivatekey()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return Curve25519KeyPairValidationError{
				field:  "Privatekey",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return Curve25519KeyPairMultiError(errors)
	}

	return nil
}

// Curve25519KeyPairMultiError is an error wrapping multiple validation errors
// returned by Curve25519KeyPair.ValidateAll() if the designated constraints
// aren't met.
type Curve25519KeyPairMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Curve25519KeyPairMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Curve25519KeyPairMultiError) AllErrors() []error { return m }

// Curve25519KeyPairValidationError is the validation error returned by
// Curve25519KeyPair.Validate if the designated constraints aren't met.
type Curve25519KeyPairValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Curve25519KeyPairValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Curve25519KeyPairValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Curve25519KeyPairValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Curve25519KeyPairValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Curve25519KeyPairValidationError) ErrorName() string {
	return "Curve25519KeyPairValidationError"
}

// Error satisfies the builtin error interface
func (e Curve25519KeyPairValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCurve25519KeyPair.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Curve25519KeyPairValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Curve25519KeyPairValidationError{}

// Validate checks the field values on UnderlayWireguard with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UnderlayWireguard) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UnderlayWireguard with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UnderlayWireguardMultiError, or nil if none found.
func (m *UnderlayWireguard) ValidateAll() error {
	return m.validate(true)
}

func (m *UnderlayWireguard) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetEndpoint()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UnderlayWireguardValidationError{
					field:  "Endpoint",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UnderlayWireguardValidationError{
					field:  "Endpoint",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEndpoint()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UnderlayWireguardValidationError{
				field:  "Endpoint",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPublicKey()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UnderlayWireguardValidationError{
					field:  "PublicKey",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UnderlayWireguardValidationError{
					field:  "PublicKey",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPublicKey()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UnderlayWireguardValidationError{
				field:  "PublicKey",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UnderlayWireguardMultiError(errors)
	}

	return nil
}

// UnderlayWireguardMultiError is an error wrapping multiple validation errors
// returned by UnderlayWireguard.ValidateAll() if the designated constraints
// aren't met.
type UnderlayWireguardMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UnderlayWireguardMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UnderlayWireguardMultiError) AllErrors() []error { return m }

// UnderlayWireguardValidationError is the validation error returned by
// UnderlayWireguard.Validate if the designated constraints aren't met.
type UnderlayWireguardValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UnderlayWireguardValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UnderlayWireguardValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UnderlayWireguardValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UnderlayWireguardValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UnderlayWireguardValidationError) ErrorName() string {
	return "UnderlayWireguardValidationError"
}

// Error satisfies the builtin error interface
func (e UnderlayWireguardValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUnderlayWireguard.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UnderlayWireguardValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UnderlayWireguardValidationError{}

// Validate checks the field values on UnderlayLinuxKernelWireguard with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UnderlayLinuxKernelWireguard) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UnderlayLinuxKernelWireguard with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UnderlayLinuxKernelWireguardMultiError, or nil if none found.
func (m *UnderlayLinuxKernelWireguard) ValidateAll() error {
	return m.validate(true)
}

func (m *UnderlayLinuxKernelWireguard) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetEndpoint()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UnderlayLinuxKernelWireguardValidationError{
					field:  "Endpoint",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UnderlayLinuxKernelWireguardValidationError{
					field:  "Endpoint",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEndpoint()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UnderlayLinuxKernelWireguardValidationError{
				field:  "Endpoint",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPublicKey()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UnderlayLinuxKernelWireguardValidationError{
					field:  "PublicKey",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UnderlayLinuxKernelWireguardValidationError{
					field:  "PublicKey",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPublicKey()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UnderlayLinuxKernelWireguardValidationError{
				field:  "PublicKey",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UnderlayLinuxKernelWireguardMultiError(errors)
	}

	return nil
}

// UnderlayLinuxKernelWireguardMultiError is an error wrapping multiple
// validation errors returned by UnderlayLinuxKernelWireguard.ValidateAll() if
// the designated constraints aren't met.
type UnderlayLinuxKernelWireguardMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UnderlayLinuxKernelWireguardMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UnderlayLinuxKernelWireguardMultiError) AllErrors() []error { return m }

// UnderlayLinuxKernelWireguardValidationError is the validation error returned
// by UnderlayLinuxKernelWireguard.Validate if the designated constraints
// aren't met.
type UnderlayLinuxKernelWireguardValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UnderlayLinuxKernelWireguardValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UnderlayLinuxKernelWireguardValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UnderlayLinuxKernelWireguardValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UnderlayLinuxKernelWireguardValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UnderlayLinuxKernelWireguardValidationError) ErrorName() string {
	return "UnderlayLinuxKernelWireguardValidationError"
}

// Error satisfies the builtin error interface
func (e UnderlayLinuxKernelWireguardValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUnderlayLinuxKernelWireguard.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UnderlayLinuxKernelWireguardValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UnderlayLinuxKernelWireguardValidationError{}

// Validate checks the field values on ASN with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *ASN) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ASN with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ASNMultiError, or nil if none found.
func (m *ASN) ValidateAll() error {
	return m.validate(true)
}

func (m *ASN) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Number

	if len(errors) > 0 {
		return ASNMultiError(errors)
	}

	return nil
}

// ASNMultiError is an error wrapping multiple validation errors returned by
// ASN.ValidateAll() if the designated constraints aren't met.
type ASNMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ASNMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ASNMultiError) AllErrors() []error { return m }

// ASNValidationError is the validation error returned by ASN.Validate if the
// designated constraints aren't met.
type ASNValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ASNValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ASNValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ASNValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ASNValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ASNValidationError) ErrorName() string { return "ASNValidationError" }

// Error satisfies the builtin error interface
func (e ASNValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sASN.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ASNValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ASNValidationError{}

// Validate checks the field values on Peer with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Peer) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Peer with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in PeerMultiError, or nil if none found.
func (m *Peer) ValidateAll() error {
	return m.validate(true)
}

func (m *Peer) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetAsnumber()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PeerValidationError{
					field:  "Asnumber",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PeerValidationError{
					field:  "Asnumber",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAsnumber()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PeerValidationError{
				field:  "Asnumber",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAddress()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PeerValidationError{
					field:  "Address",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PeerValidationError{
					field:  "Address",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAddress()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PeerValidationError{
				field:  "Address",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	switch m.Underlay.(type) {

	case *Peer_UnderlayUnknown:

		if all {
			switch v := interface{}(m.GetUnderlayUnknown()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PeerValidationError{
						field:  "UnderlayUnknown",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PeerValidationError{
						field:  "UnderlayUnknown",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUnderlayUnknown()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PeerValidationError{
					field:  "UnderlayUnknown",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Peer_UnderlayTailscale:

		if all {
			switch v := interface{}(m.GetUnderlayTailscale()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PeerValidationError{
						field:  "UnderlayTailscale",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PeerValidationError{
						field:  "UnderlayTailscale",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUnderlayTailscale()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PeerValidationError{
					field:  "UnderlayTailscale",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Peer_UnderlayWireguard:

		if all {
			switch v := interface{}(m.GetUnderlayWireguard()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PeerValidationError{
						field:  "UnderlayWireguard",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PeerValidationError{
						field:  "UnderlayWireguard",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUnderlayWireguard()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PeerValidationError{
					field:  "UnderlayWireguard",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Peer_UnderlayLinuxKernelWireguard:

		if all {
			switch v := interface{}(m.GetUnderlayLinuxKernelWireguard()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PeerValidationError{
						field:  "UnderlayLinuxKernelWireguard",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PeerValidationError{
						field:  "UnderlayLinuxKernelWireguard",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUnderlayLinuxKernelWireguard()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PeerValidationError{
					field:  "UnderlayLinuxKernelWireguard",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PeerMultiError(errors)
	}

	return nil
}

// PeerMultiError is an error wrapping multiple validation errors returned by
// Peer.ValidateAll() if the designated constraints aren't met.
type PeerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PeerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PeerMultiError) AllErrors() []error { return m }

// PeerValidationError is the validation error returned by Peer.Validate if the
// designated constraints aren't met.
type PeerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PeerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PeerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PeerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PeerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PeerValidationError) ErrorName() string { return "PeerValidationError" }

// Error satisfies the builtin error interface
func (e PeerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPeer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PeerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PeerValidationError{}

// Validate checks the field values on Peers with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Peers) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Peers with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in PeersMultiError, or nil if none found.
func (m *Peers) ValidateAll() error {
	return m.validate(true)
}

func (m *Peers) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetPeers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, PeersValidationError{
						field:  fmt.Sprintf("Peers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, PeersValidationError{
						field:  fmt.Sprintf("Peers[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return PeersValidationError{
					field:  fmt.Sprintf("Peers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return PeersMultiError(errors)
	}

	return nil
}

// PeersMultiError is an error wrapping multiple validation errors returned by
// Peers.ValidateAll() if the designated constraints aren't met.
type PeersMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PeersMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PeersMultiError) AllErrors() []error { return m }

// PeersValidationError is the validation error returned by Peers.Validate if
// the designated constraints aren't met.
type PeersValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PeersValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PeersValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PeersValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PeersValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PeersValidationError) ErrorName() string { return "PeersValidationError" }

// Error satisfies the builtin error interface
func (e PeersValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPeers.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PeersValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PeersValidationError{}

// Validate checks the field values on ListPeersRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListPeersRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListPeersRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListPeersRequestMultiError, or nil if none found.
func (m *ListPeersRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListPeersRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ListPeersRequestMultiError(errors)
	}

	return nil
}

// ListPeersRequestMultiError is an error wrapping multiple validation errors
// returned by ListPeersRequest.ValidateAll() if the designated constraints
// aren't met.
type ListPeersRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListPeersRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListPeersRequestMultiError) AllErrors() []error { return m }

// ListPeersRequestValidationError is the validation error returned by
// ListPeersRequest.Validate if the designated constraints aren't met.
type ListPeersRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListPeersRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListPeersRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListPeersRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListPeersRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListPeersRequestValidationError) ErrorName() string { return "ListPeersRequestValidationError" }

// Error satisfies the builtin error interface
func (e ListPeersRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListPeersRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListPeersRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListPeersRequestValidationError{}

// Validate checks the field values on ListPeersResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListPeersResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListPeersResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListPeersResponseMultiError, or nil if none found.
func (m *ListPeersResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListPeersResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPeers()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ListPeersResponseValidationError{
					field:  "Peers",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ListPeersResponseValidationError{
					field:  "Peers",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPeers()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ListPeersResponseValidationError{
				field:  "Peers",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return ListPeersResponseMultiError(errors)
	}

	return nil
}

// ListPeersResponseMultiError is an error wrapping multiple validation errors
// returned by ListPeersResponse.ValidateAll() if the designated constraints
// aren't met.
type ListPeersResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListPeersResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListPeersResponseMultiError) AllErrors() []error { return m }

// ListPeersResponseValidationError is the validation error returned by
// ListPeersResponse.Validate if the designated constraints aren't met.
type ListPeersResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListPeersResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListPeersResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListPeersResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListPeersResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListPeersResponseValidationError) ErrorName() string {
	return "ListPeersResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListPeersResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListPeersResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListPeersResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListPeersResponseValidationError{}

// Validate checks the field values on AddressAssignRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AddressAssignRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddressAssignRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddressAssignRequestMultiError, or nil if none found.
func (m *AddressAssignRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *AddressAssignRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if len(errors) > 0 {
		return AddressAssignRequestMultiError(errors)
	}

	return nil
}

// AddressAssignRequestMultiError is an error wrapping multiple validation
// errors returned by AddressAssignRequest.ValidateAll() if the designated
// constraints aren't met.
type AddressAssignRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddressAssignRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddressAssignRequestMultiError) AllErrors() []error { return m }

// AddressAssignRequestValidationError is the validation error returned by
// AddressAssignRequest.Validate if the designated constraints aren't met.
type AddressAssignRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddressAssignRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddressAssignRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddressAssignRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddressAssignRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddressAssignRequestValidationError) ErrorName() string {
	return "AddressAssignRequestValidationError"
}

// Error satisfies the builtin error interface
func (e AddressAssignRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddressAssignRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddressAssignRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddressAssignRequestValidationError{}

// Validate checks the field values on AddressAssignResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AddressAssignResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddressAssignResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddressAssignResponseMultiError, or nil if none found.
func (m *AddressAssignResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *AddressAssignResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetAddress()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AddressAssignResponseValidationError{
					field:  "Address",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AddressAssignResponseValidationError{
					field:  "Address",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAddress()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AddressAssignResponseValidationError{
				field:  "Address",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAsnumber()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AddressAssignResponseValidationError{
					field:  "Asnumber",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AddressAssignResponseValidationError{
					field:  "Asnumber",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAsnumber()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AddressAssignResponseValidationError{
				field:  "Asnumber",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AddressAssignResponseMultiError(errors)
	}

	return nil
}

// AddressAssignResponseMultiError is an error wrapping multiple validation
// errors returned by AddressAssignResponse.ValidateAll() if the designated
// constraints aren't met.
type AddressAssignResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddressAssignResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddressAssignResponseMultiError) AllErrors() []error { return m }

// AddressAssignResponseValidationError is the validation error returned by
// AddressAssignResponse.Validate if the designated constraints aren't met.
type AddressAssignResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddressAssignResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddressAssignResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddressAssignResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddressAssignResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddressAssignResponseValidationError) ErrorName() string {
	return "AddressAssignResponseValidationError"
}

// Error satisfies the builtin error interface
func (e AddressAssignResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddressAssignResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddressAssignResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddressAssignResponseValidationError{}

// Validate checks the field values on RegisterPeerRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RegisterPeerRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegisterPeerRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RegisterPeerRequestMultiError, or nil if none found.
func (m *RegisterPeerRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *RegisterPeerRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPeer()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, RegisterPeerRequestValidationError{
					field:  "Peer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, RegisterPeerRequestValidationError{
					field:  "Peer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPeer()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return RegisterPeerRequestValidationError{
				field:  "Peer",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return RegisterPeerRequestMultiError(errors)
	}

	return nil
}

// RegisterPeerRequestMultiError is an error wrapping multiple validation
// errors returned by RegisterPeerRequest.ValidateAll() if the designated
// constraints aren't met.
type RegisterPeerRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegisterPeerRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegisterPeerRequestMultiError) AllErrors() []error { return m }

// RegisterPeerRequestValidationError is the validation error returned by
// RegisterPeerRequest.Validate if the designated constraints aren't met.
type RegisterPeerRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegisterPeerRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegisterPeerRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegisterPeerRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegisterPeerRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegisterPeerRequestValidationError) ErrorName() string {
	return "RegisterPeerRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RegisterPeerRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegisterPeerRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegisterPeerRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegisterPeerRequestValidationError{}

// Validate checks the field values on RegisterPeerResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RegisterPeerResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RegisterPeerResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RegisterPeerResponseMultiError, or nil if none found.
func (m *RegisterPeerResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *RegisterPeerResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Ok

	if len(errors) > 0 {
		return RegisterPeerResponseMultiError(errors)
	}

	return nil
}

// RegisterPeerResponseMultiError is an error wrapping multiple validation
// errors returned by RegisterPeerResponse.ValidateAll() if the designated
// constraints aren't met.
type RegisterPeerResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegisterPeerResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegisterPeerResponseMultiError) AllErrors() []error { return m }

// RegisterPeerResponseValidationError is the validation error returned by
// RegisterPeerResponse.Validate if the designated constraints aren't met.
type RegisterPeerResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegisterPeerResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegisterPeerResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegisterPeerResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegisterPeerResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegisterPeerResponseValidationError) ErrorName() string {
	return "RegisterPeerResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RegisterPeerResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegisterPeerResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegisterPeerResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegisterPeerResponseValidationError{}

// Validate checks the field values on PeerStatus with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PeerStatus) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PeerStatus with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PeerStatusMultiError, or
// nil if none found.
func (m *PeerStatus) ValidateAll() error {
	return m.validate(true)
}

func (m *PeerStatus) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetPeer()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PeerStatusValidationError{
					field:  "Peer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PeerStatusValidationError{
					field:  "Peer",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPeer()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PeerStatusValidationError{
				field:  "Peer",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for TxBytes

	// no validation rules for RxBytes

	if uri, err := url.Parse(m.GetExporterEndpoint()); err != nil {
		err = PeerStatusValidationError{
			field:  "ExporterEndpoint",
			reason: "value must be a valid URI",
			cause:  err,
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	} else if !uri.IsAbs() {
		err := PeerStatusValidationError{
			field:  "ExporterEndpoint",
			reason: "value must be absolute",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return PeerStatusMultiError(errors)
	}

	return nil
}

// PeerStatusMultiError is an error wrapping multiple validation errors
// returned by PeerStatus.ValidateAll() if the designated constraints aren't met.
type PeerStatusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PeerStatusMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PeerStatusMultiError) AllErrors() []error { return m }

// PeerStatusValidationError is the validation error returned by
// PeerStatus.Validate if the designated constraints aren't met.
type PeerStatusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PeerStatusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PeerStatusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PeerStatusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PeerStatusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PeerStatusValidationError) ErrorName() string { return "PeerStatusValidationError" }

// Error satisfies the builtin error interface
func (e PeerStatusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPeerStatus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PeerStatusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PeerStatusValidationError{}

// Validate checks the field values on UpdatePeerStatusRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdatePeerStatusRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdatePeerStatusRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdatePeerStatusRequestMultiError, or nil if none found.
func (m *UpdatePeerStatusRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdatePeerStatusRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetPeersStatus() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, UpdatePeerStatusRequestValidationError{
						field:  fmt.Sprintf("PeersStatus[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, UpdatePeerStatusRequestValidationError{
						field:  fmt.Sprintf("PeersStatus[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return UpdatePeerStatusRequestValidationError{
					field:  fmt.Sprintf("PeersStatus[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return UpdatePeerStatusRequestMultiError(errors)
	}

	return nil
}

// UpdatePeerStatusRequestMultiError is an error wrapping multiple validation
// errors returned by UpdatePeerStatusRequest.ValidateAll() if the designated
// constraints aren't met.
type UpdatePeerStatusRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdatePeerStatusRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdatePeerStatusRequestMultiError) AllErrors() []error { return m }

// UpdatePeerStatusRequestValidationError is the validation error returned by
// UpdatePeerStatusRequest.Validate if the designated constraints aren't met.
type UpdatePeerStatusRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdatePeerStatusRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdatePeerStatusRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdatePeerStatusRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdatePeerStatusRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdatePeerStatusRequestValidationError) ErrorName() string {
	return "UpdatePeerStatusRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdatePeerStatusRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdatePeerStatusRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdatePeerStatusRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdatePeerStatusRequestValidationError{}

// Validate checks the field values on UpdatePeerStatusResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdatePeerStatusResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdatePeerStatusResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdatePeerStatusResponseMultiError, or nil if none found.
func (m *UpdatePeerStatusResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdatePeerStatusResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Ok

	if len(errors) > 0 {
		return UpdatePeerStatusResponseMultiError(errors)
	}

	return nil
}

// UpdatePeerStatusResponseMultiError is an error wrapping multiple validation
// errors returned by UpdatePeerStatusResponse.ValidateAll() if the designated
// constraints aren't met.
type UpdatePeerStatusResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdatePeerStatusResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdatePeerStatusResponseMultiError) AllErrors() []error { return m }

// UpdatePeerStatusResponseValidationError is the validation error returned by
// UpdatePeerStatusResponse.Validate if the designated constraints aren't met.
type UpdatePeerStatusResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdatePeerStatusResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdatePeerStatusResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdatePeerStatusResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdatePeerStatusResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdatePeerStatusResponseValidationError) ErrorName() string {
	return "UpdatePeerStatusResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdatePeerStatusResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdatePeerStatusResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdatePeerStatusResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdatePeerStatusResponseValidationError{}
