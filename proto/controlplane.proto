syntax = "proto3";
option go_package = "./spec";

import "protoc-gen-validate/validate/validate.proto";

service ControlPlaneService {
  rpc ListPeers(ListPeersRequest) returns (ListPeersResponse);
  rpc AddressAssign(AddressAssignRequest) returns (AddressAssignResponse);
  rpc RegisterPeer(RegisterPeerRequest) returns (RegisterPeerResponse);
  rpc UpdatePeerStatus(UpdatePeerStatusRequest) returns (UpdatePeerStatusResponse);
}

message AddressIPv4{
  string ipaddress = 1 [(validate.rules).string.ipv4 = true];
}
message AddressIPv6{
  string ipaddress = 1 [(validate.rules).string.ipv6 = true];
}

message Address {
  oneof ipaddress {
    option (validate.required) = true;
    AddressIPv4 addressIPv4 = 2;
    AddressIPv6 addressIPv6 = 3;
  }
}

message AddressCIDRIPv4 {
  AddressIPv4 ipaddress = 1 [(validate.rules).message.required = true];
  int32 mask = 2 [(validate.rules).int32 = {gte: 0, lte:32}];
}

message AddressCIDRIPv6 {
  AddressIPv6 ipaddress = 1 [(validate.rules).message.required = true];
  int32 mask = 2 [(validate.rules).int32 = {gte: 0, lte:128}];
}

message AddressCIDR {
  oneof addresscidr {
    option (validate.required) = true;
    AddressCIDRIPv4 addressCIDRIPv4 = 2;
    AddressCIDRIPv6 addressCIDRIPv6 = 3;
  }
}

message AddressAndPort {
  Address ipaddress = 1;
  int32 port = 2 [(validate.rules).int32 = {gte: 1, lte:65535}];
}

message UnderlayUnknown {
  Address endpoint = 1 [(validate.rules).message.required = true];
}

message UnderlayTailscale {
  Address endpoint = 1 [(validate.rules).message.required = true];
}

message Curve25519Key {
  bytes key = 1 [(validate.rules).bytes.len = 32];
}

message Curve25519KeyPair {
  Curve25519Key publickey = 1 [(validate.rules).message.required = true];
  Curve25519Key privatekey = 2 [(validate.rules).message.required = true];
}

message UnderlayWireguard {
  AddressAndPort endpoint = 1 [(validate.rules).message.required = true];
  Curve25519Key publicKey = 2 [(validate.rules).message.required = true];
}

message UnderlayLinuxKernelWireguard {
  AddressAndPort endpoint = 1 [(validate.rules).message.required = true];
  Curve25519Key publicKey = 2 [(validate.rules).message.required = true];
}

message ASN {
  uint32 number = 1;
}

message SourceBasedRoutingOption {
  repeated AddressCIDR sourceIPRange = 1;
}

message Peer {
  string name = 1;
  ASN asnumber = 2 [(validate.rules).message.required = true];
  repeated AddressCIDR address = 3;
  oneof underlay {
    option (validate.required) = true;
    UnderlayUnknown underlayUnknown = 4;
    UnderlayTailscale underlayTailscale = 5;
    UnderlayWireguard underlayWireguard = 6;
    UnderlayLinuxKernelWireguard underlayLinuxKernelWireguard = 7;
  }
  SourceBasedRoutingOption sbrOption = 8;
}

message Peers {
  repeated Peer peers = 1;
}

message ListPeersRequest {
}

message ListPeersResponse {
  Peers peers = 1;
}

message AddressAssignRequest {
  string name = 1;
}

message AddressAssignResponse {
  repeated AddressCIDR address = 1 [(validate.rules).repeated.min_items = 1];
  ASN asnumber = 2 [(validate.rules).message.required = true];
}

message RegisterPeerRequest {
  Peer peer = 1 [(validate.rules).message.required = true];
}

message RegisterPeerResponse {
  bool ok = 1;
}

message PeerStatus {
  Peer peer = 1 [(validate.rules).message.required = true];
  uint64 txBytes = 2;
  uint64 rxBytes = 3;
  string exporterEndpoint = 4 [(validate.rules).string.uri = true];
}

message UpdatePeerStatusRequest {
  repeated PeerStatus peersStatus = 1;
}

message UpdatePeerStatusResponse {
  bool ok = 1;
}
